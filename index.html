<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go Game</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 500px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 12px;
        }
        
        .player-info {
            text-align: center;
            flex: 1;
        }
        
        .player-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .player-score {
            font-size: 18px;
            font-weight: bold;
        }
        
        .black .player-name { color: #2c3e50; }
        .white .player-name { color: #7f8c8d; }
        
        .board-container {
            position: relative;
            margin: 20px 0;
            background: #dcb35c;
            border: 2px solid #8b4513;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .board {
            display: grid;
            gap: 0;
            width: 100%;
            aspect-ratio: 1;
            position: relative;
        }
        
        .board-line {
            position: absolute;
            background: #000;
        }
        
        .horizontal-line {
            width: 100%;
            height: 1px;
            left: 0;
        }
        
        .vertical-line {
            width: 1px;
            height: 100%;
            top: 0;
        }
        
        .intersection {
            position: absolute;
            width: calc(100% / 6);
            height: calc(100% / 6);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        .stone {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        .black-stone {
            background: radial-gradient(circle at 30% 30%, #666, #000);
        }
        
        .white-stone {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            border: 1px solid #999;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .pass-btn {
            background: #3498db;
            color: white;
        }
        
        .undo-btn {
            background: #e74c3c;
            color: white;
        }
        
        .new-game-btn {
            background: #2ecc71;
            color: white;
            grid-column: 1 / -1;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .status {
            text-align: center;
            margin: 15px 0;
            padding: 10px;
            background: #ecf0f1;
            border-radius: 10px;
            font-weight: bold;
        }
        
        .current-turn {
            border: 3px solid #f39c12;
            padding: 8px;
            border-radius: 12px;
        }

        .error {
            color: #e74c3c;
            background: #ffeaa7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ –ò–≥—Ä–∞ –ì–æ</h1>
            <div class="status" id="status">–•–æ–¥ —á—ë—Ä–Ω—ã—Ö</div>
        </div>
        
        <div class="game-info">
            <div class="player-info black current-turn" id="black-info">
                <div class="player-name">–ß—ë—Ä–Ω—ã–µ (B)</div>
                <div class="player-score">–ü–ª–µ–Ω–Ω—ã–µ: <span id="black-captures">0</span></div>
            </div>
            <div class="player-info white" id="white-info">
                <div class="player-name">–ë–µ–ª—ã–µ (W)</div>
                <div class="player-score">–ü–ª–µ–Ω–Ω—ã–µ: <span id="white-captures">0</span></div>
            </div>
        </div>
        
        <div class="board-container">
            <div class="board" id="board"></div>
        </div>
        
        <div class="controls">
            <button class="pass-btn" onclick="passTurn()">–ü–∞—Å</button>
            <button class="undo-btn" onclick="undoMove()">–û—Ç–º–µ–Ω–∏—Ç—å —Ö–æ–¥</button>
            <button class="new-game-btn" onclick="newGame()">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        </div>
    </div>

    <script>
        // –¢–û–ß–ù–û –¢–í–û–ò –°–¢–†–£–ö–¢–£–†–´ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
        const PointColor = {
            EMPTY: '.',
            BLACK: 'B', 
            WHITE: 'W'
        };

        const GameRules = {
            JAPANESE: 0,
            CHINESE: 1
        };

        class GameSettings {
            constructor() {
                this.BoardSize = 7;
                this.Komi = 6.5;
                this.Rules = GameRules.JAPANESE;
                this.Handicap = 0;
                this.BlackName = "Black";
                this.WhiteName = "White";
                this.Event = "";
            }
        }

        class GoNode {
            constructor(parent, board, move, order, color, blackCaptures, whiteCaptures) {
                this.Parent = parent;
                this.Children = [];
                this.Board = board;
                this.LatestMove = move;
                this.NodeOrder = order;
                this.LastMoveColor = color;
                this.BlackCaptures = blackCaptures;
                this.WhiteCaptures = whiteCaptures;
            }
        }

        class Chain {
            constructor() {
                this.ChainMap = {};
                this.Dame = 0;
                this.Color = PointColor.EMPTY;
                this.StoneCount = 0;
            }
        }

        class GoTree {
            constructor(settings) {
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–∫ –≤ —Ç–≤–æ–µ–º NewGoTree
                this.GameSettings = settings;
                const board = Array(settings.BoardSize * settings.BoardSize).fill(PointColor.EMPTY);
                
                this.Root = new GoNode(
                    null, 
                    board, 
                    -1, 
                    0, 
                    PointColor.BLACK, 
                    0, 
                    0
                );
                
                this.CurrentNode = this.Root;
                this.Result = "";
                this.Winner = "";
                this.CreatedAt = new Date();
            }

            makeMove(move) {
                // #1 –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ found among the children
                for (let i = 0; i < this.CurrentNode.Children.length; i++) {
                    const child = this.CurrentNode.Children[i];
                    if (child.LatestMove === move) {
                        this.CurrentNode = child;
                        return null; // –£—Å–ø–µ—Ö
                    }
                }

                // #2 –ë–∞–∑–æ–≤–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è
                if (move < 0 || move >= this.GameSettings.BoardSize * this.GameSettings.BoardSize) {
                    return `Move ${move} out of board range`;
                }
                if (this.CurrentNode.Board[move] !== PointColor.EMPTY) {
                    return `Point ${move} already occupied`;
                }

                // –°–æ–∑–¥–∞–µ–º tempBoard —Å –Ω–æ–≤—ã–º —Ö–æ–¥–æ–º
                const tempBoard = [...this.CurrentNode.Board];
                tempBoard[move] = this.oppositeColor(this.CurrentNode.LastMoveColor);

                // –°–æ–∑–¥–∞–µ–º –ø–æ–ª–µ–∑–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
                let totalCaptured = 0;
                const capturedChains = [];
                const neighbors = this.getNeighbors(move);
                let    enemyNeighborCount = 0

                // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–æ—Å–µ–¥–Ω–µ–≥–æ-–≤—Ä–∞–∂–µ—Å–∫–æ–≥–æ –∫–∞–º–Ω—è –ø—Ä–æ–≤–µ—Ä—è–µ–º –∂–∏–∑–Ω—å –µ–≥–æ –≥—Ä—É–ø–ø—ã
                for (const neighbor of neighbors) {
                    if (this.isEnemyStone(tempBoard[neighbor])) {
                        const enemyChain = this.findChainAt(tempBoard, neighbor);
                        if (enemyChain && this.isChainDead(enemyChain)) { 
                            totalCaptured += enemyChain.StoneCount;
                            capturedChains.push(enemyChain);
                        }
                        enemyNeighborCount = enemyNeighborCount + 1
                    }
                }

                // #3 –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ö–æ
                // #4 –ï—Å–ª–∏ –±–æ–ª—å—à–µ totalCaptured > 1, —Ç–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥
                if (totalCaptured >= 1) {
                    if (totalCaptured === 1 && this.CurrentNode.Parent && 
                        this.CurrentNode.Parent.Board[move] === this.CurrentNode.Parent.LastMoveColor && enemyNeighborCount === 4) {
                        return "Ko violation";
                    }
                } else {
                    // #5 –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–∞–º–æ—É–±–∏–π—Å—Ç–≤–µ–Ω–Ω—ã–π —Ö–æ–¥
                    const myChain = this.findChainAt(tempBoard, move);
                    if (myChain && this.isChainDead(myChain)) {
                        return "Suicide move not allowed";
                    }
                }

                // –£–†–ê –í–´ –ü–†–û–®–õ–ò –ü–†–û–í–ï–†–ö–ò!
                this.removeCapturedStones(tempBoard, capturedChains);

                // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–ª–µ–Ω–Ω–∏–∫–æ–≤
                let blackCaptures = this.CurrentNode.BlackCaptures;
                let whiteCaptures = this.CurrentNode.WhiteCaptures;
                
                if (this.CurrentNode.LastMoveColor === PointColor.WHITE) {
                    whiteCaptures += totalCaptured;
                } else {
                    blackCaptures += totalCaptured;
                }

                // –ù–æ–≤—ã–π —É–∑–µ–ª - –¢–û–ß–ù–û –ö–ê–ö –£ –¢–ï–ë–Ø
                const newNode = new GoNode(
                    this.CurrentNode,
                    tempBoard,
                    move,
                    this.CurrentNode.NodeOrder + 1,
                    this.oppositeColor(this.CurrentNode.LastMoveColor),
                    blackCaptures,
                    whiteCaptures
                );

                // –î–æ–±–∞–≤–ª—è–µ–º —É–∑–µ–ª –≤ Children
                this.CurrentNode.Children.push(newNode);

                // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ –Ω–æ–≤—ã–π —É–∑–µ–ª
                this.CurrentNode = newNode;
                return null; // –£—Å–ø–µ—Ö
            }

            oppositeColor(color) {
                if (color === PointColor.BLACK) return PointColor.WHITE;
                if (color === PointColor.WHITE) return PointColor.BLACK;
                return PointColor.EMPTY;
            }

            removeCapturedStones(board, capturedChains) {
                for (const chain of capturedChains) {
                    for (const pos in chain.ChainMap) {
                        if (chain.ChainMap[pos]) {
                            board[parseInt(pos)] = PointColor.EMPTY;
                        }
                    }
                }
            }

            isEnemyStone(color) {
                if (color === PointColor.EMPTY) return false;
                return color !== this.oppositeColor(this.CurrentNode.LastMoveColor);
            }

            getNeighbors(pos) {
                const neighbors = [];
                const boardSize = this.GameSettings.BoardSize;
                const row = Math.floor(pos / boardSize);
                const col = pos % boardSize;
                
                if (row > 0) neighbors.push(pos - boardSize);
                if (row < boardSize - 1) neighbors.push(pos + boardSize);
                if (col > 0) neighbors.push(pos - 1);
                if (col < boardSize - 1) neighbors.push(pos + 1);
                
                return neighbors;
            }

            findChainAt(board, startPos) {
                if (board[startPos] === PointColor.EMPTY) {
                    return null;
                }

                const chain = new Chain();
                chain.Color = board[startPos];
                
                this.findConnectedStones(chain, board, startPos);
                this.calculateDame(chain, board);
                
                return chain;
            }

            findConnectedStones(chain, board, startPos) {
                const visited = {};
                const queue = [startPos];
                const boardSize = this.GameSettings.BoardSize;
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    if (visited[current]) continue;
                    visited[current] = true;
                    
                    chain.ChainMap[current] = true;
                    chain.StoneCount++;
                    
                    const neighbors = this.getNeighbors(current);
                    for (const neighbor of neighbors) {
                        if (!visited[neighbor] && board[neighbor] === chain.Color) {
                            queue.push(neighbor);
                        }
                    }
                }
            }

            calculateDame(chain, board) {
                let dameCount = 0;
                const visitedDame = {};
                const boardSize = this.GameSettings.BoardSize;
                
                for (const pos in chain.ChainMap) {
                    const numPos = parseInt(pos);
                    const neighbors = this.getNeighbors(numPos);
                    for (const neighbor of neighbors) {
                        if (board[neighbor] === PointColor.EMPTY && !visitedDame[neighbor]) {
                            dameCount++;
                            visitedDame[neighbor] = true;
                        }
                    }
                }
                
                chain.Dame = dameCount;
            }

            isChainDead(chain) {
                return chain.Dame === 0;
            }

            passTurn() {
                // –°–æ–∑–¥–∞–µ–º —É–∑–µ–ª –ø–∞—Å–∞ (—Ö–æ–¥ -1)
                const newNode = new GoNode(
                    this.CurrentNode,
                    [...this.CurrentNode.Board], // –¢–∞ –∂–µ –¥–æ—Å–∫–∞
                    -1, // –ü–∞—Å
                    this.CurrentNode.NodeOrder + 1,
                    this.oppositeColor(this.CurrentNode.LastMoveColor),
                    this.CurrentNode.BlackCaptures,
                    this.CurrentNode.WhiteCaptures
                );

                this.CurrentNode.Children.push(newNode);
                this.CurrentNode = newNode;
            }

            undoMove() {
                if (this.CurrentNode.Parent) {
                    this.CurrentNode = this.CurrentNode.Parent;
                    return true;
                }
                return false;
            }

            getCurrentBoard() {
                return this.CurrentNode.Board;
            }

            getCurrentPlayer() {
                return this.CurrentNode.LastMoveColor;
            }

            getCaptures() {
                return {
                    black: this.CurrentNode.BlackCaptures,
                    white: this.CurrentNode.WhiteCaptures
                };
            }
        }

        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò –§–†–û–ù–¢–ï–ù–î
        let gameTree;

        function initGame() {
            const settings = new GameSettings();
            gameTree = new GoTree(settings); // –°–û–ó–î–ê–ï–ú GoTree
            createBoardUI();
            updateUI();
            
            // Telegram Web App
            if (window.Telegram && Telegram.WebApp) {
                Telegram.WebApp.ready();
                Telegram.WebApp.expand();
            }
        }

        function createBoardUI() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            const size = gameTree.GameSettings.BoardSize;
            
            // –°–æ–∑–¥–∞–µ–º –ª–∏–Ω–∏–∏ –¥–æ—Å–∫–∏
            for (let i = 0; i < size; i++) {
                const hLine = document.createElement('div');
                hLine.className = 'board-line horizontal-line';
                hLine.style.top = `${i * (100 / (size - 1))}%`;
                boardElement.appendChild(hLine);
                
                const vLine = document.createElement('div');
                vLine.className = 'board-line vertical-line';
                vLine.style.left = `${i * (100 / (size - 1))}%`;
                boardElement.appendChild(vLine);
            }
            
            // –°–æ–∑–¥–∞–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –¥–ª—è —Ö–æ–¥–æ–≤
            for (let i = 0; i < size * size; i++) {
                const intersection = document.createElement('div');
                intersection.className = 'intersection';
                intersection.style.left = `${(i % size) * (100 / (size - 1))}%`;
                intersection.style.top = `${Math.floor(i / size) * (100 / (size - 1))}%`;
                
                intersection.addEventListener('click', () => {
                    // –í–´–ó–´–í–ê–ï–ú –¢–í–û–ô MakeMove
                    const error = gameTree.makeMove(i);
                    if (error) {
                        showMessage(error);
                    } else {
                        updateUI();
                    }
                });
                
                boardElement.appendChild(intersection);
            }
        }

        function passTurn() {
            gameTree.passTurn();
            updateUI();
            showMessage(`–ü–∞—Å! –•–æ–¥ ${gameTree.getCurrentPlayer() === PointColor.BLACK ? '—á—ë—Ä–Ω—ã—Ö' : '–±–µ–ª—ã—Ö'}`);
        }

        function undoMove() {
            if (gameTree.undoMove()) {
                updateUI();
            }
        }

        function newGame() {
            initGame();
        }

        function updateUI() {
            // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ò–ó GoTree
            const board = gameTree.getCurrentBoard();
            const currentPlayer = gameTree.getCurrentPlayer();
            const captures = gameTree.getCaptures();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–º–Ω–∏ –Ω–∞ –¥–æ—Å–∫–µ
            const intersections = document.getElementsByClassName('intersection');
            for (let i = 0; i < intersections.length; i++) {
                intersections[i].innerHTML = '';
                
                if (board[i] === PointColor.BLACK) {
                    const stone = document.createElement('div');
                    stone.className = 'stone black-stone';
                    intersections[i].appendChild(stone);
                } else if (board[i] === PointColor.WHITE) {
                    const stone = document.createElement('div');
                    stone.className = 'stone white-stone';
                    intersections[i].appendChild(stone);
                }
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç
            document.getElementById('black-captures').textContent = captures.black;
            document.getElementById('white-captures').textContent = captures.white;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
            document.getElementById('status').textContent = 
                `–•–æ–¥ ${currentPlayer === PointColor.BLACK ? '—á—ë—Ä–Ω—ã—Ö' : '–±–µ–ª—ã—Ö'}`;
            document.getElementById('status').className = 'status';
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
            document.getElementById('black-info').classList.toggle('current-turn', 
                currentPlayer === PointColor.BLACK);
            document.getElementById('white-info').classList.toggle('current-turn', 
                currentPlayer === PointColor.WHITE);
        }

        function showMessage(message) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status error';
            
            setTimeout(() => {
                updateUI();
            }, 2000);
        }

        // –ó–ê–ü–£–°–ö–ê–ï–ú –ò–ì–†–£ –ü–†–ò –ó–ê–ì–†–£–ó–ö–ï
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
